import json
import sys
import os
import re
import urllib.request
from typing import Dict, List, Set


def загрузить_конфигурацию(путь_к_файлу: str) -> Dict:
    """Загрузить и проверить конфигурацию из JSON файла"""

    # Проверка существования файла
    if not os.path.exists(путь_к_файлу):
        print(f"ОШИБКА: Файл конфигурации не найден: {путь_к_файлу}", file=sys.stderr)
        sys.exit(1)

    # Чтение JSON
    try:
        with open(путь_к_файлу, 'r', encoding='utf-8') as f:
            конфиг = json.load(f)
    except json.JSONDecodeError as e:
        print(f"ОШИБКА: Неверный формат JSON: {e}", file=sys.stderr)
        sys.exit(1)

    # Проверка обязательных параметров
    обязательные = ['имя_пакета', 'адрес_репозитория', 'тестовый_режим']
    for параметр in обязательные:
        if параметр not in конфиг:
            print(f"ОШИБКА: Отсутствует обязательный параметр: {параметр}", file=sys.stderr)
            sys.exit(1)

    # Проверка типов и значений
    if not isinstance(конфиг['имя_пакета'], str) or not конфиг['имя_пакета'].strip():
        print("ОШИБКА: имя_пакета должно быть непустой строкой", file=sys.stderr)
        sys.exit(1)

    if not isinstance(конфиг['адрес_репозитория'], str) or not конфиг['адрес_репозитория'].strip():
        print("ОШИБКА: адрес_репозитория должен быть непустой строкой", file=sys.stderr)
        sys.exit(1)
        
    return конфиг


def показать_конфигурацию(конфиг: Dict):
    """Этап 1: Вывести все параметры конфигурации"""
    print("=" * 60)
    print("ПАРАМЕТРЫ КОНФИГУРАЦИИ")
    print("=" * 60)
    print(f"имя_пакета: {конфиг['имя_пакета']}")
    print(f"адрес_репозитория: {конфиг['адрес_репозитория']}")
    print(f"тестовый_режим: {конфиг['тестовый_режим']}")
    print(f"имя_выходного_файла: {конфиг['имя_выходного_файла']}")
    print(f"режим_ascii_дерева: {конфиг['режим_ascii_дерева']}")
    print(f"подстрока_фильтра: {конфиг['подстрока_фильтра']}")
    print("=" * 60)


def загрузить_тестовый_репозиторий(путь: str) -> Dict[str, List[str]]:
    """Загрузить тестовый репозиторий из файла"""
    репозиторий = {}

    try:
        with open(путь, 'r', encoding='utf-8') as f:
            for строка in f:
                строка = строка.strip()

                # Пропускаем пустые строки и комментарии
                if not строка or строка.startswith('#'):
                    continue

                # Формат: ПАКЕТ: ЗАВ1, ЗАВ2, ЗАВ3
                if ':' not in строка:
                    continue

                пакет, зависимости_строка = строка.split(':', 1)
                пакет = пакет.strip()
                зависимости_строка = зависимости_строка.strip()

                if зависимости_строка:
                    зависимости = [з.strip() for з in зависимости_строка.split(',') if з.strip()]
                else:
                    зависимости = []

                репозиторий[пакет] = зависимости

    except Exception as e:
        print(f"ОШИБКА при чтении тестового репозитория: {e}", file=sys.stderr)
        sys.exit(1)

    return репозиторий


def получить_зависимости_из_apt(адрес: str, имя_пакета: str) -> List[str]:
    """Получить прямые зависимости из apt репозитория"""

    # Пробуем загрузить файл Packages
    возможные_urls = [
        f"{адрес.rstrip('/')}/Packages",
        f"{адрес.rstrip('/')}/Packages.gz",
    ]

    содержимое = None
    for url in возможные_urls:
        try:
            with urllib.request.urlopen(url, timeout=30) as response:
                данные = response.read()

                # Распаковываем gzip если нужно
                if url.endswith('.gz'):
                    import gzip
                    данные = gzip.decompress(данные)

                содержимое = данные.decode('utf-8')
                break
        except:
            continue

    if not содержимое:
        print(f"ОШИБКА: Не удалось загрузить Packages файл из {адрес}", file=sys.stderr)
        sys.exit(1)

    # Парсим файл Packages
    текущий_пакет = None
    текущие_зависимости = None

    for строка in содержимое.split('\n'):
        if строка.startswith('Package:'):
            текущий_пакет = строка.split(':', 1)[1].strip()
            текущие_зависимости = None

        elif строка.startswith('Depends:') and текущий_пакет == имя_пакета:
            текущие_зависимости = строка.split(':', 1)[1].strip()

        elif текущие_зависимости is not None and строка.startswith(' '):
            текущие_зависимости += ' ' + строка.strip()

        elif not строка.strip():
            if текущий_пакет == имя_пакета:
                if текущие_зависимости:
                    зависимости = []
                    for часть in текущие_зависимости.split(','):
                        часть = часть.strip()
                        if '|' in часть:
                            часть = часть.split('|')[0].strip()
                        match = re.match(r'^([a-zA-Z0-9.+\-]+)', часть)
                        if match:
                            зависимости.append(match.group(1))

                    return зависимости
                else:
                    return []

    print(f"ОШИБКА: Пакет '{имя_пакета}' не найден в репозитории", file=sys.stderr)
    sys.exit(1)


def получить_прямые_зависимости(конфиг: Dict, репозиторий: Dict = None) -> List[str]:
    """Этап 2: Получить прямые зависимости пакета"""

    имя = конфиг['имя_пакета']

    if конфиг['тестовый_режим']:
        if имя not in репозиторий:
            print(f"ОШИБКА: Пакет '{имя}' не найден в тестовом репозитории", file=sys.stderr)
            sys.exit(1)
        return репозиторий[имя]
    else:
        return получить_зависимости_из_apt(конфиг['адрес_репозитория'], имя)


def построить_граф_bfs(имя_пакета: str, конфиг: Dict, репозиторий: Dict = None) -> Dict[str, List[str]]:
    """Этап 3: Построить граф зависимостей с помощью BFS с рекурсией"""

    граф = {}
    посещенные = set()
    в_обработке = set()
    подстрока = конфиг.get('подстрока_фильтра', '')

    def нужно_фильтровать(пакет: str) -> bool:
        """Проверить, нужно ли отфильтровать пакет"""
        return подстрока and подстрока in пакет

    def bfs_рекурсивный(очередь: List[str]):
        """Рекурсивный BFS для построения графа"""
        if not очередь:
            return

        следующая_очередь = []

        for пакет in очередь:
            # Пропускаем уже обработанные
            if пакет in посещенные:
                continue

            # Фильтруем если нужно
            if нужно_фильтровать(пакет):
                continue

            # Проверка на цикл
            if пакет in в_обработке:
                continue

            в_обработке.add(пакет)

            # Получаем зависимости
            try:
                if конфиг['тестовый_режим']:
                    if пакет in репозиторий:
                        зависимости = репозиторий[пакет]
                    else:
                        зависимости = []
                else:
                    try:
                        зависимости = получить_зависимости_из_apt(конфиг['адрес_репозитория'], пакет)
                    except:
                        зависимости = []

                # Фильтруем зависимости
                зависимости = [з for з in зависимости if not нужно_фильтровать(з)]

                граф[пакет] = зависимости

                # Добавляем новые зависимости в очередь
                for зав in зависимости:
                    if зав not in посещенные and зав not in в_обработке:
                        следующая_очередь.append(зав)

            except:
                граф[пакет] = []

            в_обработке.remove(пакет)
            посещенные.add(пакет)

        # Рекурсивно обрабатываем следующий уровень
        if следующая_очередь:
            bfs_рекурсивный(следующая_очередь)

    # Запускаем BFS
    bfs_рекурсивный([имя_пакета])

    return граф


def показать_граф(граф: Dict[str, List[str]]):
    """Вывести граф зависимостей"""
    print("\nГраф зависимостей:")
    print("-" * 60)

    for пакет in sorted(граф.keys()):
        зависимости = граф[пакет]
        if зависимости:
            print(f"{пакет}:")
            for зав in зависимости:
                print(f"  -> {зав}")
        else:
            print(f"{пакет}: (нет зависимостей)")

    print("-" * 60)
    print(f"Всего пакетов в графе: {len(граф)}")


def вычислить_порядок_загрузки(граф: Dict[str, List[str]]) -> List[str]:
    """Этап 4: Вычислить порядок загрузки зависимостей (топологическая сортировка)"""

    # Вычисляем степень входа для каждого пакета
    степени = {}
    все_пакеты = set(граф.keys())

    # Добавляем все упомянутые пакеты
    for зависимости in граф.values():
        все_пакеты.update(зависимости)

    # Инициализируем степени
    for пакет in все_пакеты:
        степени[пакет] = 0

    # Вычисляем степени входа
    for зависимости in граф.values():
        for зав in зависимости:
            степени[зав] += 1

    # Очередь пакетов без зависимостей
    очередь = [п for п in все_пакеты if степени[п] == 0]
    порядок = []

    while очередь:
        очередь.sort()
        пакет = очередь.pop(0)
        порядок.append(пакет)

        # Уменьшаем степень для зависимых пакетов
        if пакет in граф:
            for зав in граф[пакет]:
                степени[зав] -= 1
                if степени[зав] == 0:
                    очередь.append(зав)

    # Если есть циклы, добавляем оставшиеся пакеты
    if len(порядок) < len(все_пакеты):
        оставшиеся = все_пакеты - set(порядок)
        порядок.extend(sorted(оставшиеся))

    return порядок


def создать_mermaid_диаграмму(граф: Dict[str, List[str]], корневой_пакет: str) -> str:
    """Этап 5: Создать диаграмму Mermaid"""

    строки = ["graph TD"]

    for пакет, зависимости in sorted(граф.items()):
        пакет_id = пакет.replace('-', '_').replace('.', '_')

        if зависимости:
            for зав in зависимости:
                зав_id = зав.replace('-', '_').replace('.', '_')
                строки.append(f"    {пакет_id}[{пакет}] --> {зав_id}[{зав}]")
        else:
            строки.append(f"    {пакет_id}[{пакет}]")

    # Выделяем корневой пакет
    корень_id = корневой_пакет.replace('-', '_').replace('.', '_')
    строки.append(f"    style {корень_id} fill:#f9f,stroke:#333,stroke-width:4px")

    return '\n'.join(строки)


def сохранить_диаграмму(mermaid_код: str, имя_файла: str):
    """Сохранить диаграмму в файл"""

    # Пробуем использовать mermaid-cli
    import subprocess
    import tempfile

    try:
        with tempfile.NamedTemporaryFile(mode='w', suffix='.mmd', delete=False) as f:
            f.write(mermaid_код)
            temp_файл = f.name
            path_to_mmdc = r"C:\Users\Ww_Videira_wW\AppData\Roaming\npm\mmdc.cmd"
        result = subprocess.run(
            [path_to_mmdc, '-i', temp_файл, '-o', имя_файла],
            capture_output=True,
            timeout=30
        )

        if result.returncode == 0:
            print(f"\nSVG диаграмма сохранена: {имя_файла}")
        else:
            raise Exception("Не удалось конвертировать")

    except:
        # Сохраняем .mmd файл
        mmd_файл = имя_файла.replace('.svg', '.mmd')
        with open(mmd_файл, 'w', encoding='utf-8') as f:
            f.write(mermaid_код)

        print(f"\nMermaid диаграмма сохранена: {mmd_файл}")
        print("(для конвертации в SVG установите: npm install -g @mermaid-js/mermaid-cli)")

    finally:
        try:
            if 'temp_файл' in locals():
                os.unlink(temp_файл)
        except:
            pass


def создать_ascii_дерево(граф: Dict[str, List[str]], пакет: str, префикс: str = "",
                         последний: bool = True, посещенные: Set[str] = None) -> List[str]:
    """Создать ASCII дерево зависимостей"""

    if посещенные is None:
        посещенные = set()

    строки = []

    if префикс == "":
        строки.append(пакет)
    else:
        соединитель = "└── " if последний else "├── "
        строки.append(префикс + соединитель + пакет)

    # Проверка на цикл
    if пакет in посещенные:
        префикс_цикла = префикс + ("    " if последний else "│   ")
        строки.append(префикс_цикла + "(цикл обнаружен)")
        return строки

    посещенные = посещенные.copy()
    посещенные.add(пакет)

    # Обрабатываем зависимости
    if пакет in граф:
        зависимости = граф[пакет]
        for i, зав in enumerate(зависимости):
            последний_зав = (i == len(зависимости) - 1)
            новый_префикс = префикс + ("    " if последний else "│   ")
            строки.extend(создать_ascii_дерево(граф, зав, новый_префикс, последний_зав, посещенные))

    return строки


def main():
    """Главная функция"""

    if len(sys.argv) != 2:
        print("Использование: python dep_visualizer.py <файл_конфигурации.json>", file=sys.stderr)
        sys.exit(1)

    # Этап 1: Загрузка конфигурации
    конфиг = загрузить_конфигурацию(sys.argv[1])
    показать_конфигурацию(конфиг)

    # Загружаем тестовый репозиторий если нужно
    репозиторий = None
    if конфиг['тестовый_режим']:
        репозиторий = загрузить_тестовый_репозиторий(конфиг['адрес_репозитория'])

    # Этап 2: Извлечение прямых зависимостей
    print("\n" + "=" * 60)
    print("ЭТАП 2: ИЗВЛЕЧЕНИЕ ПРЯМЫХ ЗАВИСИМОСТЕЙ")
    print("=" * 60)

    имя_пакета = конфиг['имя_пакета']
    print(f"\nПолучение прямых зависимостей для пакета: {имя_пакета}")

    прямые_зависимости = получить_прямые_зависимости(конфиг, репозиторий)

    if прямые_зависимости:
        print(f"\nПрямые зависимости ({len(прямые_зависимости)}):")
        for i, зав in enumerate(прямые_зависимости, 1):
            print(f"  {i}. {зав}")
    else:
        print(f"\nПакет '{имя_пакета}' не имеет зависимостей")

    # Этап 3: Построение графа зависимостей
    print("\n" + "=" * 60)
    print("ЭТАП 3: ПОСТРОЕНИЕ ГРАФА ЗАВИСИМОСТЕЙ")
    print("=" * 60)

    if конфиг.get('подстрока_фильтра'):
        print(f"\nФильтрация пакетов содержащих: '{конфиг['подстрока_фильтра']}'")

    print(f"\nПостроение графа зависимостей для: {имя_пакета}")
    print("Используется алгоритм BFS с рекурсией...")

    граф = построить_граф_bfs(имя_пакета, конфиг, репозиторий)
    показать_граф(граф)

    # Этап 4: Порядок загрузки
    print("\n" + "=" * 60)
    print("ЭТАП 4: ПОРЯДОК ЗАГРУЗКИ ЗАВИСИМОСТЕЙ")
    print("=" * 60)

    порядок = вычислить_порядок_загрузки(граф)

    print("\nПорядок загрузки (зависимости загружаются первыми):")
    for i, пакет in enumerate(порядок, 1):
        print(f"  {i}. {пакет}")

    # Этап 5: Визуализация
    print("\n" + "=" * 60)
    print("ЭТАП 5: ВИЗУАЛИЗАЦИЯ")
    print("=" * 60)

    mermaid = создать_mermaid_диаграмму(граф, имя_пакета)

    print("\nMermaid диаграмма:")
    print("-" * 60)
    print(mermaid)
    print("-" * 60)

    сохранить_диаграмму(mermaid, конфиг['имя_выходного_файла'])

    # ASCII дерево если нужно
    if конфиг.get('режим_ascii_дерева'):
        print("\nASCII дерево зависимостей:")
        print("-" * 60)
        дерево = создать_ascii_дерево(граф, имя_пакета)
        for строка in дерево:
            print(строка)
    print("\n" + "=" * 60)

if __name__ == "__main__":
    main()